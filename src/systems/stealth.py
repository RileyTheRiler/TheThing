from typing import Dict, List, Optional
from src.core.design_briefs import DesignBriefRegistry
from src.core.event_system import event_bus, EventType, GameEvent
from src.core.resolution import Attribute, ResolutionSystem, Skill
from src.systems.room_state import RoomState
from src.entities.crew_member import StealthPosture

class StealthSystem:
    """
    Handles stealth encounters by reacting to TURN_ADVANCE events.
    Key mechanic: Subject Pool vs Observer Pool contest using ResolutionSystem.
    """

    def __init__(self, design_registry: Optional[DesignBriefRegistry] = None):
        self.design_registry = design_registry or DesignBriefRegistry()
        self.config = self.design_registry.get_brief("stealth")
        self.cooldown = 0
        event_bus.subscribe(EventType.TURN_ADVANCE, self.on_turn_advance)

    def cleanup(self):
        event_bus.unsubscribe(EventType.TURN_ADVANCE, self.on_turn_advance)

    def _detect_candidates(self, crew) -> List:
        """Return infected crew sharing a room with the player."""
        return [m for m in crew if getattr(m, "is_infected", False) and getattr(m, "is_alive", True)]

    def on_turn_advance(self, event: GameEvent):
        if self.cooldown > 0:
            self.cooldown -= 1

        game_state = event.payload.get("game_state")
        rng = event.payload.get("rng")
        if not game_state or rng is None:
            return

        player = getattr(game_state, "player", None)
        crew = getattr(game_state, "crew", [])
        station_map = getattr(game_state, "station_map", None)
        room_states = getattr(game_state, "room_states", None)
        
        if not player or not station_map:
            return

        room = station_map.get_room_name(*player.location)
        nearby_infected = [
            m for m in self._detect_candidates(crew)
            if getattr(m, "location", None) == player.location
        ]

        if not nearby_infected or self.cooldown > 0:
            return

        opponent = nearby_infected[0]
        
        # 1. Subject Pool (Player Stealth)
        prowess = player.attributes.get(Attribute.PROWESS, 1) if hasattr(player, "attributes") else 2
        stealth = player.skills.get(Skill.STEALTH, 0) if hasattr(player, "skills") else 0
        subject_pool = prowess + stealth

        # 2. Observer Pool (Infected NPC Perception)
        logic = opponent.attributes.get(Attribute.LOGIC, 1)
        observation = opponent.skills.get(Skill.OBSERVATION, 0)
        observer_pool = logic + observation

        # 3. Modifiers (Posture and Environment)
        posture = getattr(player, "stealth_posture", StealthPosture.STANDING)
        
        # Posture Modifiers (Subject Bonus)
        if posture == StealthPosture.CROUCHING:
            subject_pool += 1
        elif posture == StealthPosture.CRAWLING:
            subject_pool += 2
        elif posture == StealthPosture.HIDING:
            subject_pool += 4

        # Environmental Modifiers
        is_dark = room_states.has_state(room, RoomState.DARK) if room_states else False
        if is_dark:
            subject_pool += 2
            # Darkness hinders observation
            observer_pool = max(1, observer_pool - 2)
        
        # Enforce minimum pool of 1
        subject_pool = max(1, subject_pool)
        observer_pool = max(1, observer_pool)

        # 4. Resolution
        res = ResolutionSystem()
        
        subject_result = res.roll_check(subject_pool, rng)
        observer_result = res.roll_check(observer_pool, rng)
        
        # Success = Subject (Player) has MORE successes than Observer (NPC)
        # Ties go to the Observer (Detection favored in horror)
        player_evaded = subject_result['success_count'] > observer_result['success_count']
        
        payload = {
            "room": room,
            "opponent": opponent.name,
            "outcome": "evaded" if player_evaded else "detected",
            "player_successes": subject_result['success_count'],
            "opponent_successes": observer_result['success_count'],
            "subject_pool": subject_pool,
            "observer_pool": observer_pool
        }
        event_bus.emit(GameEvent(EventType.STEALTH_REPORT, payload))
        
        # Emit AI perception event for other systems to hook into
        event_bus.emit(GameEvent(EventType.PERCEPTION_EVENT, payload))

        if not player_evaded:
            event_bus.emit(GameEvent(EventType.WARNING, {
                "text": f"{opponent.name} corners you in the {room}!"
            }))
        else:
            event_bus.emit(GameEvent(EventType.MESSAGE, {
                "text": f"You stay hidden from {opponent.name} in the {room}."
            }))

        self.cooldown = self.config.get("cooldown_turns", 1)

    def get_noise_level(self, character) -> int:
        """
        Calculate noise level generated by a character.
        Base 5 + Inventory Weight - Stealth Skill.
        """
        base_noise = 5
        
        # Simple simplified weight (count of items for now)
        weight = len(character.inventory) if hasattr(character, 'inventory') else 0
        
        stealth = character.skills.get(Skill.STEALTH, 0) if hasattr(character, 'skills') else 0
        
        posture_mod = 0
        posture = getattr(character, "stealth_posture", StealthPosture.STANDING)
        if posture == StealthPosture.CROUCHING:
            posture_mod = -2
        elif posture == StealthPosture.CRAWLING:
            posture_mod = -4
            
        return max(1, base_noise + weight - stealth + posture_mod)

    def evaluate_detection(self, observer, subject, game_state, noise_level=None) -> bool:
        """
        Check if observer detects subject.
        Returns True if detected.
        """
        if noise_level is None:
            noise_level = self.get_noise_level(subject)
            
        # Observer: Logic + Observation
        logic = observer.attributes.get(Attribute.LOGIC, 1)
        observation = observer.skills.get(Skill.OBSERVATION, 0)
        pool = logic + observation
        
        res = ResolutionSystem()
        result = res.roll_check(pool, game_state.rng)
        
        # Difficulty is the noise level? Or opposed roll?
        # Let's say Difficulty = Stealth Result (Subject Pool)
        # But here we are given noise level. 
        # Let's map Noise Level to Difficulty Target Successes for simplicity
        # Low noise = High difficulty
        
        # Alternatively, simpler comparison: 
        # successes > (10 - noise_level)/2 ?
        
        # Let's stick to the mechanics in on_turn_advance: Subject vs Observer
        # But this method is called by AI which might cache noise.
        
        # Re-using the mechanic:
        prowess = subject.attributes.get(Attribute.PROWESS, 1)
        stealth = subject.skills.get(Skill.STEALTH, 0)
        subject_pool = prowess + stealth
        
        subject_result = res.roll_check(subject_pool, game_state.rng)
        
        return result['success_count'] >= subject_result['success_count']
